// motor_rodoseru02と03を合体させ、前身右左折と停止を行えるプログラム

#include "iodefine.h"
#include <machine.h>
#include <stdio.h>
#include <stdint.h>
#include <mathf.h>
#include "vect.h"
#define PCLK 25000 // 周辺機器のクロック設定　25000kHz


//---------------------------------------------------------
// 関数
//---------------------------------------------------------
void change_oscillation_PLL(void)
{
	unsigned int i;
    SYSTEM.PRCR.WORD = 0xA507;
    SYSTEM.VRCR = 0x00;
    SYSTEM.MOFCR.BYTE = (0x30);
    SYSTEM.MOSCWTCR.BYTE = (0x0D);
    SYSTEM.MOSCCR.BYTE = 0x00;
    while (0x00 != SYSTEM.MOSCCR.BYTE){}
    for(i=0;i<100;i++) nop();
    SYSTEM.PLLCR.WORD = (0x0901);
    SYSTEM.PLLWTCR.BYTE = (0x09);
    SYSTEM.PLLCR2.BYTE = 0x00;
    for(i=0;i<100;i++) nop();
    SYSTEM.OPCCR.BYTE = (0x00);
    while (0 != SYSTEM.OPCCR.BIT.OPCMTSF){}
    SYSTEM.SCKCR.LONG = 0x21821211;
    while (0x21821211 != SYSTEM.SCKCR.LONG){}
    SYSTEM.BCKCR.BYTE = 0x01;
    while (0x01 != SYSTEM.BCKCR.BYTE){}
    SYSTEM.SCKCR3.WORD = (0x0400);
    while ((0x0400) != SYSTEM.SCKCR3.WORD){}
    SYSTEM.PRCR.WORD = 0xA500;
}
void init_CMT0(void) {
	SYSTEM.PRCR.WORD = 0xA502;  // プロテクト解除
	MSTP(CMT0) = 0;             // CMT0モジュールスタンバイ解除
	SYSTEM.PRCR.WORD = 0xA500;  // プロテクト設定

	CMT0.CMCR.BIT.CKS = 0;      // クロック: PCLK/8 (25MHz / 8 = 3.125MHz)
	CMT0.CMCR.BIT.CMIE = 1;     // コンペアマッチ割り込み許可

	CMT0.CMCR.BIT.CKS = 0;      // PCLK/8
	CMT0.CMCOR = 3125-1;        // 500Hz周期  25MHz÷8÷3125=1000Hz
	CMT0.CMCNT = 0;             // カウンタ初期化

	IEN(CMT0, CMI0)= 1;         // 割り込み許可
	IPR(CMT0, CMI0)= 5;         // 優先度設定

	CMT.CMSTR0.BIT.STR0 = 1;    // タイマスタート
}

void initMTUsyncPWM(void) {
	SYSTEM.PRCR.WORD = 0x0A502;
	MSTP(MTU0) = 0;                //MTU0 モジュールスタンバイ解除
	MSTP(MTU1) = 0;                //MTU1 モジュールスタンバイ解除
	MSTP(MTU2) = 0;                //MTU2 モジュールスタンバイ解除
	SYSTEM.PRCR.WORD = 0x0A500;
	/* MTUタイマの設定 */
	MTU.TSTR.BIT.CST0 = 0x00;	//MTUカウント停止
	MTU.TSTR.BIT.CST1 = 0x00;	//MTUカウント停止
	MTU.TSTR.BIT.CST2 = 0x00;	//MTUカウント停止
	/* 同期動作の設定 */
	MTU.TSYR.BIT.SYNC0 = 0x01;	//MTU0同期動作
	MTU.TSYR.BIT.SYNC1 = 0x01;	//MTU1同期動作
	MTU.TSYR.BIT.SYNC2 = 0x01;	//MTU2同期動作
	/* カウント設定 */
	MTU0.TCR.BIT.TPSC = 0x01;	// CLK PCLK/4 でカウント
	MTU1.TCR.BIT.TPSC = 0x01;	// CLK PCLK/4 でカウント
	MTU2.TCR.BIT.TPSC = 0x01;	// CLK PCLK/4 でカウント
	/* カウンタのクリア要因設定 */
	MTU0.TMDR.BIT.MD = 0x03;	//タイマーPWMモード2
	MTU1.TMDR.BIT.MD = 0x03;	//タイマーPWMモード2
	MTU2.TMDR.BIT.MD = 0x03;	//タイマーPWMモード2
	MTU0.TCR.BIT.CCLR = 0x01;	//TCNT0はTGRAのコンペアマッチでクリア
	MTU1.TCR.BIT.CCLR = 0x03;	//TCNT1は同期クリア/同期動作をしている他のチャネルのカウンタクリアでTCNTをクリア
	MTU2.TCR.BIT.CCLR = 0x03;	//TCNT2は同期クリア/同期動作をしている他のチャネルのカウンタクリアでTCNTをクリア
	/* 波形出力の設定 */
	MTU0.TIORH.BIT.IOB = 0x02;	// MTIOC0B 初期出力はLow出力コンペアマッチでHigh出力
	MTU0.TIORL.BIT.IOC = 0x02;	// MTIOC0C 初期出力はLow出力コンペアマッチでHigh出力
	MTU0.TIORL.BIT.IOD = 0x02;	// MTIOC0D 初期出力はLow出力コンペアマッチでHigh出力
	MTU1.TIOR.BIT.IOA = 0x02;	// MTIOC1A 初期出力はLow出力コンペアマッチでHigh出力
	MTU1.TIOR.BIT.IOB = 0x02;	// MTIOC1B 初期出力はLow出力コンペアマッチでHigh出力
	MTU2.TIOR.BIT.IOA = 0x02;	// MTIOC2A 初期出力はLow出力コンペアマッチでHigh出力
	MTU2.TIOR.BIT.IOB = 0x02;	// MTIOC2B 初期出力はLow出力コンペアマッチでHigh出力
	/* ピンの設定 */ //この中のピンがINに繋がるように
	PORT1.PODR.BIT.B5 = 0;		// P15 MTIOC0B 出力初期値
	PORT1.PDR.BIT.B5 = 1;		// P15 出力設定
	PORT1.PMR.BIT.B5 = 0;		// P15 ポートとして使用
	PORT3.PODR.BIT.B2 = 0;		// P32 MTIOC0C 出力初期値
	PORT3.PDR.BIT.B2 = 1;		// P32 出力設定
	PORT3.PMR.BIT.B2 = 0;		// P32 ポートとして使用
	PORT3.PODR.BIT.B3 = 0;		// P33 MTIOC0D 出力初期値
	PORT3.PDR.BIT.B3 = 1;		// P33 出力設定
	PORT3.PMR.BIT.B3 = 0;		// P33 ポートとして使用
	PORTE.PODR.BIT.B4 = 0;		// PE4 MTIOC1A 出力初期値
	PORTE.PDR.BIT.B4 = 1;		// PE4 出力設定
	PORTE.PMR.BIT.B4 = 0;		// PE4 ポートとして使用
	PORTB.PODR.BIT.B5 = 0;		// PB5 MTIOC1B 出力初期値
	PORTB.PDR.BIT.B5 = 1;		// PB5 出力設定
	PORTB.PMR.BIT.B5 = 0;		// PB5 ポートとして使用
	PORT2.PODR.BIT.B6 = 0;		// P26 MTIOC2A 出力初期値
	PORT2.PDR.BIT.B6 = 1;		// P26 出力設定
	PORT2.PMR.BIT.B6 = 0;		// P26 ポートとして使用
	PORT2.PODR.BIT.B7 = 0;		// P27 MTIOC2B 出力初期値
	PORT2.PDR.BIT.B7 = 1;		// P27 出力設定
	PORT2.PMR.BIT.B7 = 0;		// P27 ポートとして使用
	/* 保護解除 */
	MPC.PWPR.BIT.B0WI = 0;		// PFSWE書き込み可
	MPC.PWPR.BIT.PFSWE = 1;		// PFSレジスタへの書き込み可
	/* ピンの機能設定 */
	MPC.P15PFS.BIT.PSEL = 1;	// P15をMTIOC0Bとして使用
	MPC.P32PFS.BIT.PSEL = 1;	// P32をMTIOC0Cとして使用
	MPC.P33PFS.BIT.PSEL = 1;	// P33をMTIOC0Dとして使用
	MPC.PE4PFS.BIT.PSEL = 2;	// PE4をMTIOC1Aとして使用
	MPC.PB5PFS.BIT.PSEL = 2;	// PB5をMTIOC1Bとして使用
	MPC.P26PFS.BIT.PSEL = 1;	// P26をMTIOC2Aとして使用
	MPC.P27PFS.BIT.PSEL = 1;	// P26をMTIOC2Bとして使用
	/* 保護 */
	MPC.PWPR.BIT.PFSWE = 0;		// PFSレジスタへの書き込み禁止
	/*　ピンを周辺機器に設定 */
	PORT1.PMR.BIT.B5 = 1;		// P15周辺機器として使用  IN3
	PORT3.PMR.BIT.B2 = 1;		// P32周辺機器として使用  IN2
	PORT3.PMR.BIT.B3 = 1;		// P33周辺機器として使用  IN1
	PORTE.PMR.BIT.B4 = 1;		// PE4周辺機器として使用
	PORTB.PMR.BIT.B5 = 1;		// PB5周辺機器として使用
	PORT2.PMR.BIT.B6 = 1;		// P26周辺機器として使用
	PORT2.PMR.BIT.B7 = 1;		// P27周辺機器として使用
	/* 初期値設定 */
	MTU0.TGRA = 255;			// 周波数設定
	MTU0.TGRB = 0;			// MTIOC0Bのデューティー比設定 256以上の設定はデューティー比 0
	MTU0.TGRC = 0;			// MTIOC0Cのデューティー比設定
	MTU0.TGRD = 0;			// MTIOC0Dのデューティー比設定
	MTU1.TGRA = 0;			// MTIOC1Aのデューティー比設定
	MTU1.TGRB = 0;			// MTIOC1Bのデューティー比設定
	MTU2.TGRA = 0;			// MTIOC2Aのデューティー比設定
	MTU2.TGRB = 0;			// MTIOC2Bのデューティー比設定
	/* MTUタイマ起動 */
	MTU.TSTR.BIT.CST0 = 0x01;	//MTU0カウント動作
	MTU.TSTR.BIT.CST1 = 0x01;	//MTU1カウント動作
	MTU.TSTR.BIT.CST2 = 0x01;	//MTU2カウント動作
}
//---------------------------------------------------------
// モーター関連
//---------------------------------------------------------
// 変数
volatile int realSpeed = 0;			// 実際の速度を示す変数
volatile int turnL = 0;
volatile int turnR = 0;
volatile int speedL = 0;
volatile int speedR = 0;

// 定数の指定
#define PWM_OFF 0
#define ic_ON  0
#define ic_OFF 1


typedef enum{
	IN,
	SD,
	Motor_PCNT    // Motor_PIN_COUNTの略
}Motor_PINS;

typedef enum{
	Phase_V,
	Phase_U,
	Phase_W,
	Motor_PHSCNT   // Moter_PHASE_COUNTの略
}Motor_PHASES;

typedef struct {
    volatile uint16_t *tgr;   // タイマレジスタ (IN用)
    volatile uint8_t  *podr;  // 出力レジスタ (SD用)
    uint8_t            bit;   // ビット位置
} Motor_t;

typedef struct {
    volatile uint8_t  *pidr;  // 入力レジスタ (HL用)
    uint8_t            bit;   // ビット位置
} HL_t;

// 初期化を楽にするためのマクロ
#define Motor_IN(tgr_ptr)      {(volatile uint16_t*)tgr_ptr, 0, 0}
#define Motor_SD(port, bit)    {0, (volatile uint8_t*)&PORT##port.PODR.BYTE, (uint8_t)(1<<bit)}
#define Motor_HL(port, bit)    {(volatile uint8_t*)&PORT##port.PIDR.BYTE, (uint8_t)(1<<bit)}

const Motor_t Motor_L[Motor_PHSCNT][Motor_PCNT] = {
        {Motor_IN(&MTU0.TGRC), Motor_SD(5, 1)},
		{Motor_IN(&MTU0.TGRD), Motor_SD(5, 0)},
		{Motor_IN(&MTU0.TGRB), Motor_SD(5, 2)},
};

const Motor_t Motor_R[Motor_PHSCNT][Motor_PCNT] = {
		{Motor_IN(&MTU1.TGRB), Motor_SD(5, 4)},
		{Motor_IN(&MTU1.TGRA), Motor_SD(5, 3)},
		{Motor_IN(&MTU2.TGRB), Motor_SD(5, 5)},
};

typedef enum {
	Left,
	Right,
	Motor_SCNT
}Motor_SIDE;

const HL_t HL[Motor_SCNT][Motor_PHSCNT] = {
	{Motor_HL(D, 0), Motor_HL(D, 1), Motor_HL(D, 2)},
	{Motor_HL(D, 3), Motor_HL(D, 4), Motor_HL(D, 5)}
};

uint8_t read_HSIG(const HL_t*pin){
	if(*(pin->pidr) & (pin->bit)) return 1;
	else return 0;
}
/*
// 配線の接続の指定
// J6 左側のモーター
#define VL_SD PORT5.PODR.BIT.B1
#define UL_SD PORT5.PODR.BIT.B0
#define WL_SD PORT5.PODR.BIT.B2

#define VL_IN MTU0.TGRC
#define UL_IN MTU0.TGRD
#define WL_IN MTU0.TGRB

// J4 左側のホールセンサー

#define HVL PORTD.PIDR.BIT.B0
#define HUL PORTD.PIDR.BIT.B1
#define HWL PORTD.PIDR.BIT.B2

// J7 右側のモーター
#define VR_SD PORT5.PODR.BIT.B4
#define UR_SD PORT5.PODR.BIT.B3
#define WR_SD PORT5.PODR.BIT.B5

#define VR_IN MTU1.TGRB
#define UR_IN MTU1.TGRA
#define WR_IN MTU2.TGRB

// J5 右側のホールセンサー

#define HVR PORTD.PIDR.BIT.B3
#define HUR PORTD.PIDR.BIT.B4
#define HWR PORTD.PIDR.BIT.B5

*/

typedef enum {
	PATTERN_OFF,
	PATTERN_1,
	PATTERN_2,
	PATTERN_3,
	PATTERN_4,
	PATTERN_5,
	PATTERN_6,
	PATTERN_CNT
}PATTERNS;

typedef enum {
	OUT_OFF,
	OUT_PWM,
	OUT_ON
}OutMode;

const OutMode CommutationTable[PATTERN_CNT][Motor_PHSCNT] = {
    {OUT_OFF, OUT_OFF, OUT_OFF},
    {OUT_ON,  OUT_PWM, OUT_OFF}, // V=ON,  U=PWM, W=OFF
    {OUT_OFF, OUT_PWM, OUT_ON }, // V=OFF, U=PWM, W=ON
    {OUT_PWM, OUT_OFF, OUT_ON }, // V=PWM, U=OFF, W=ON
    {OUT_PWM, OUT_ON,  OUT_OFF}, // V=PWM, U=ON,  W=OFF
    {OUT_OFF, OUT_ON,  OUT_PWM}, // V=OFF, U=ON,  W=PWM
    {OUT_ON,  OUT_OFF, OUT_PWM}  // V=ON,  U=OFF, W=PWM
};

int get_sensor_state(Motor_SIDE side){
	int state = 0;
	if(read_HSIG(&HL[side][Phase_V])) state |= 2;
	if(read_HSIG(&HL[side][Phase_U])) state |= 4;
	if(read_HSIG(&HL[side][Phase_W])) state |= 1;
	return state;
}

#define SENS_PATTERN_1 (!U &&  V && !W)
#define SENS_PATTERN_2 (!U &&  V &&  W)
#define SENS_PATTERN_3 (!U && !V &&  W)
#define SENS_PATTERN_4 ( U && !V &&  W)
#define SENS_PATTERN_5 ( U && !V && !W)
#define SENS_PATTERN_6 ( U &&  V && !W)


// 電流が少ないバターン
// ホールセンサの値を読み込んでモータが回転するために必要な印加電圧を作成する
// 右側
void apply_motor_control(const Motor_t cfg[Motor_PHSCNT][Motor_PCNT], PATTERNS pat, int speed) {
	Motor_PHASES phase;
	if (pat >= PATTERN_CNT) pat = PATTERN_OFF;

    for (phase = Phase_V; phase <= Phase_W; phase++) {
        OutMode mode = CommutationTable[pat][phase];

        // 配列からIN(TGR)とSD(PODR)の情報を取得
        const Motor_t *pin_in = &cfg[phase][IN];
        const Motor_t *pin_sd = &cfg[phase][SD];

        switch (mode) {
            case OUT_PWM:
                *(pin_in->tgr) = (uint16_t)speed;        // 0-254を代入
                *(pin_sd->podr) &= (uint8_t)~(pin_sd->bit); // ic_ON (0)
                break;

            case OUT_ON:
                *(pin_in->tgr) = PWM_OFF;                // 0
                *(pin_sd->podr) &= (uint8_t)~(pin_sd->bit); // ic_ON (0)
                break;

            case OUT_OFF:
            default:
                *(pin_in->tgr) = PWM_OFF;                // 0
                *(pin_sd->podr) |= (uint8_t)(pin_sd->bit);  // ic_OFF (1)
                break;
        }
    }
}


void BLDC(Motor_t m_cfg[Motor_PHSCNT][Motor_PCNT], Motor_SIDE wheel_side, int turn, int speed)
{
	static int oldpattern[Motor_SCNT] = {0, 0}; // 左右独立して保持
	int pattern;
	static int intCount[Motor_SCNT] = {0, 0};
	int sensor_pos = 0;
	int state_sens;
	intCount[wheel_side]++;


	// センサの状態からパターンを決定
	// 1. センサの状態から物理位置を特定
	pattern = PATTERN_OFF;
	state_sens = get_sensor_state(wheel_side);

	// 2. 状態から物理的な位置(sensor_pos)を特定
	switch(state_sens) {
		case 2: sensor_pos = PATTERN_1; break; // !U,  V, !W
	    case 3: sensor_pos = PATTERN_2; break; // !U,  V,  W
	    case 1: sensor_pos = PATTERN_3; break; // !U, !V,  W
	    case 5: sensor_pos = PATTERN_4; break; //  U, !V,  W
	    case 4: sensor_pos = PATTERN_5; break; //  U, !V, !W
	    case 6: sensor_pos = PATTERN_6; break; //  U,  V, !W
	    default:    sensor_pos = PATTERN_OFF; break;
	}

	if (sensor_pos == 0) {
		     apply_motor_control(m_cfg, PATTERN_OFF, 0);
		     return;
	}

	// 回転方向に応じてパターンを変更
	if(turn >= 0) {
		pattern = (sensor_pos % 6) + 1;
		//pattern = pattern ;
	} else {
		//pattern = (pattern - 4 + 6) % 6 + 1;
		pattern = (sensor_pos - 3 + 6) % 6 + 1;
	}

	// パターンに応じた動作
	apply_motor_control(m_cfg,(PATTERNS)pattern, speed);


	// 回転数の計測
	if(pattern != oldpattern[wheel_side]) {
		realSpeed[wheel_side] = intCount[wheel_side];
		intCount[wheel_side] = 0;
	}
	oldpattern[wheel_side] = pattern;
}


// 時間を数える
volatile int timer500 = 0;

#pragma interrupt (Excep_CMT0_CMI0(vect=28))
void Excep_CMT0_CMI0(void) {
	BLDCR(HUR, HVR, HWR, turnR,speedR);
	timer500++;
	BLDCL(HUL, HVL, HWL, turnL,speedL);
	timer500++;
}


// 時間待ち関数
// mSec 単位で待つ
void delay500(int dtime)
{
	int waitcount;
	waitcount = dtime;
	timer500 = 0;
	while(timer500 < waitcount); //時間がくるまで待つ
}
// 回転速度の計算
static float to_rpm(int intCount)
{
	int pole_pairs = 15;
	float fCMT = 1000.0f; // 割込み周期
	if (intCount <= 0)
		return 0.0f;
	return (60.0f * fCMT) / (intCount * 6.0f * pole_pairs);
}

//---------------------------------------------------------
// ロードセル関連
//---------------------------------------------------------
#define OUT_VOL 0.002f //定格出力 [V]
#define LOAD 20000.0f //定格容量 [g]
typedef enum{
	LC_CLK,
	LC_DATA,
	LC_PNUM
} LC_PINS;

typedef enum {
	LC1,
	LC2,
	LC3,
	LC4,
	LC_KNUM
} LC_KINDS;

void R_DELAY_Us (unsigned long us, unsigned long khz);

typedef struct {
    volatile uint8_t *REG; // レジスタのベースアドレス
    uint8_t BIT_POS;       // ビットの位置 (0-7)
} PIN_t;

#define PIN_DEF(port, bit) { (volatile uint8_t *)&PORT##port.PDR.BYTE, (uint8_t)(1 << bit) }
#define PIN_OUT_DEF(port, bit) { (volatile uint8_t *)&PORT##port.PODR.BYTE, (uint8_t)(1 << bit) }
#define PIN_IN_DEF(port, bit) { (volatile uint8_t *)&PORT##port.PIDR.BYTE, (uint8_t)(1 << bit) }

const PIN_t LC_init[LC_KNUM][LC_PNUM] = {
    { PIN_DEF(C, 0), PIN_DEF(C, 1) },
    { PIN_DEF(C, 2), PIN_DEF(C, 3) },
    { PIN_DEF(C, 4), PIN_DEF(C, 5) },
    { PIN_DEF(C, 6), PIN_DEF(C, 7) },
};

const PIN_t LC_IO[LC_KNUM][LC_PNUM] = {
    { PIN_OUT_DEF(C, 0), PIN_IN_DEF(C, 1) },
    { PIN_OUT_DEF(C, 2), PIN_IN_DEF(C, 3) },
    { PIN_OUT_DEF(C, 4), PIN_IN_DEF(C, 5) },
    { PIN_OUT_DEF(C, 6), PIN_IN_DEF(C, 7) },
};

void activate_pin_dir(const PIN_t *pin, int mode){
	if(mode == 1){
		*(pin->REG) |= pin->BIT_POS;
	}else{
		*(pin->REG) &= ~(pin->BIT_POS);
	}
}

void activate_pin(const PIN_t *pin, uint8_t val){
	if(val == 1){
		*(pin->REG) |= pin->BIT_POS;
	}else{
		*(pin->REG) &= ~(pin->BIT_POS);
	}
}

uint8_t read_pin(const PIN_t *pin) {
    if (*(pin->REG) & pin->BIT_POS) {
        return 1;
    } else {
        return 0;
    }
}

void AE_HX711_Init(void) //2つのピン設定
{
	int LC_PIN, LC_KIND;

	for(LC_KIND = 0; LC_KIND < LC_KNUM; LC_KIND++){
		for(LC_PIN = 0; LC_PIN < LC_PNUM; LC_PIN++){
			if(LC_PIN == 0){
				activate_pin_dir(&LC_init[LC_KIND][LC_PIN], 1);
			} else{
				activate_pin_dir(&LC_init[LC_KIND][LC_PIN], 0);
			}

		}
	}
	for(LC_KIND = 0; LC_KIND < LC_KNUM; LC_KIND++) activate_pin(&LC_IO[LC_KIND][LC_CLK], 1);
	R_DELAY_Us(100, 50000);//100μs待つ
	for(LC_KIND = 0; LC_KIND < LC_KNUM; LC_KIND++) activate_pin(&LC_IO[LC_KIND][LC_CLK], 0);
	R_DELAY_Us(100, 50000);//100μs待つ
}

//---------------------------------------------------------
// 1個目のロードセル
//---------------------------------------------------------
long AE_HX711_Read(int LC_num)
{
	int i; 						//変数の宣言
	long data = 0; 				//変数の宣言

	while (&LC_IO[LC_num][LC_DATA] != 0); //pin_dout

	R_DELAY_Us(10, 50000); 		//10μ秒待つ

	for (i = 0; i < 24; i++) { 	//24回繰り替えす
		activate_pin(&LC_IO[LC_num][LC_CLK], 1); 	//pni_slkを1にする
		R_DELAY_Us(5, 50000); 	//5μ秒待つ
		activate_pin(&LC_IO[LC_num][LC_CLK], 0); 	//pni_slkを0にする
		R_DELAY_Us(5, 50000); 	//5μ秒待つ
		data = (data << 1) | (read_pin(&LC_IO[LC_num][LC_DATA])); //data変数を1シフトし、空いた末尾のケタにpin_doutの状態を読み代入する
	}

	activate_pin(&LC_IO[LC_num][LC_CLK], 1);
	R_DELAY_Us(10, 50000); 		//10μ秒待つ
	activate_pin(&LC_IO[LC_num][LC_CLK], 0); 			//pni_slkを0にする
	R_DELAY_Us(10, 50000); 		// 10μ秒待つ

	return data ^ 0x800000; 	//dataと右辺のビット差を戻り値とする。
}
long AE_HX711_Averaging(int LC_num, int num)
{
	int i;
	long sum = 0;
	for (i = 0; i < num; i++) sum += AE_HX711_Read(LC_num);
	return sum / num;
}
float AE_HX711_getGram(int LC_num, int num)
{
#define HX711_R1 20000.0f
#define HX711_R2 0.002f
#define HX711_VBG 1.25f
#define HX711_AVDD 4.2987f
#define HX711_ADC1bit HX711_AVDD/16777216
#define HX711_PGA 128
#define HX711_SCALE (OUT_VOL * HX711_AVDD / LOAD *HX711_PGA)

	float data;

	data = (float)AE_HX711_Averaging(LC_num, num)*HX711_ADC1bit;
	data = data / HX711_SCALE;

	return data;
}

/*-----------------------------------------------------*/
/*    ウェイトコーティング									   */
/*-----------------------------------------------------*/
#pragma inline_asm R_DELAY
static void R_DELAY  (unsigned long loop_cnt)
{
    BRA     ?+
    NOP
?:
    NOP
    SUB     #01H,R1
    BNE     ?-
}
void R_DELAY_Us (unsigned long us, unsigned long khz)
{

    signed long loop_cnt; /* Argument of R_DELAY function */

    /* Calculation of a loop count */
    loop_cnt = us * khz;
    loop_cnt = (loop_cnt / 5000 );      /* Division about cycle of 1 loop */
    loop_cnt = loop_cnt - 4;            /* Overhead is reduced from a loop count. */

    /* R_DELAY function is performed when loop_cnt is 1 or more. */
    if(loop_cnt > 0)
    {
        R_DELAY((unsigned long)loop_cnt);
    }
}
/*-----------------------------------------------------*/
/*    メイン関数   									   */
/*-----------------------------------------------------*/
void main(void)
{
	// 長方形を横1,縦1の正方形と見立てる。
	LC_KINDS LC_KIND;
	float data[LC_KNUM];
	float offset[LC_KNUM];
	float weight[LC_KNUM];
	float weight_total;
	float LC_dist_per[LC_KNUM];
	float radius, theta;
	float X, Y, XG, YG, preXG, preYG, dXG, dGY;

	int i;
	PORT5.PDR.BYTE = 0xff;
	PORTD.PDR.BYTE = 0x00;

	init_CMT0();
	initMTUsyncPWM();
	change_oscillation_PLL();
	AE_HX711_Init();
	for(LC_KIND = LC1; LC_KIND <= LC4; LC_KIND++) offset[LC_KIND] = AE_HX711_getGram(LC_KIND, 10);
	PORTA.PDR.BYTE = 0xff;
	PORTA.PODR.BYTE = 0xff;

	while (1) {
		for(LC_KIND = LC1; LC_KIND <= LC4; LC_KIND++) {
			data[LC_KIND] = AE_HX711_getGram(LC_KIND, 10);
			weight[LC_KIND] = data[LC_KIND] - offset[LC_KIND];
			if(weight[LC_KIND] < 0)  weight[LC_KIND] = 0;
			weight_total += weight[LC_KIND];
		}

		// 重心位置の座標の計算
		if(weight_total < 5000){ // 基準値の変更
			XG = 0;
			YG = 0;
			speedL = 0;
			speedR = 0;
			PORTA.PODR.BYTE = 0xff;
			continue;
		}else{
			XG = (weight[LC1] - weight[LC2] + weight[LC3] - weight[LC4]) / weight_total;
			YG = (weight[LC1] + weight[LC2] - weight[LC3] - weight[LC4]) / weight_total;
		}

		// 全体の重さ(W)
		for(LC_KIND = LC1; LC_KIND <= LC4; LC_KIND++){
			weight_total += weight[LC_KIND];
		}

		// ロードセルの比重を算出
		for(LC_KIND = LC1; LC_KIND <= LC4; LC_KIND++){
			LC_dist_per[LC_KIND] = (weight[LC_KIND]/weight_total)*100;
		}

		// 座標平面変換
		X = (weight_total/2)*XG;
		Y = (weight_total/2)*YG;

		// 向いている方向を算出
		if((X < -100 && X > 100) || (Y < -100 && Y > 100)){
			X = 0;
			Y = 0;
			continue;
		}

		// 極座標平面変換
		radius = sqrt((float)pow(XG,2) + (float)pow(YG,2));
		theta = atan2(YG, XG);
		printf("radius: %f  theta: %f \n", radius, theta);
		printf("LC_dist_per[LC1]: %f", LC_dist_per[LC1]);
		printf("LC_dist_per[LC2]: %f", LC_dist_per[LC2]);
		printf("LC_dist_per[LC3]: %f", LC_dist_per[LC3]);
		printf("LC_dist_per[LC4]: %f", LC_dist_per[LC4]);
		for(i=0;i<2000;i++){
			R_DELAY_Us(1000, 50000); 		// 1m秒待つ
		}


		/*
		printf("%f g \n",weight01);
		printf("%f g \n",weight02);
		printf("%f g \n",weight03);
		printf("%f g \n",weight04);
		printf("((XG = %f), (YG = %f))\n", XG, YG);
		printf("全体の値 = %f\n",W);

		for(i=0;i<2000;i++){
			R_DELAY_Us(1000, 50000); 		// 1m秒待つ
		}
		*/
	}
}
